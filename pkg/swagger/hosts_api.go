/*
 * Host API
 *
 * API for posting hosts and waiting for hosts
 *
 * OpenAPI spec version: 1.0.0
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the MIT License
 */

package swagger

import (
	"encoding/json"
	"errors"
	"fmt"
	"net"
	"net/url"
	"strings"
	"time"
)

type HostsApi struct {
	Configuration Configuration
}

func NewHostsApi() *HostsApi {
	configuration := NewConfiguration()
	return &HostsApi{
		Configuration: *configuration,
	}
}

func NewHostsApiWithBasePath(basePath string) *HostsApi {
	configuration := NewConfiguration()
	configuration.BasePath = basePath

	return &HostsApi{
		Configuration: *configuration,
	}
}

/**
 * Hosts API
 * The hosts endpoint returns information about games currently being hosted and known about by the system.
 *
 * @param gameId Game to look for hosts under.
 * @param status Status(es) of hosts to return. If not given, the default is Wait, Play, Relay.
 * @param hoster Name or part of a name of a hoster.
 * @param country Countries for a host.
 * @return *HostList
 */
func (a HostsApi) GamesGameIdHostHostIdPost(gameId string, hostId string, checkInfo StatusUpdate) (*StatusCheckResult, *APIResponse, error) {
	// create path and map variables
	path := a.Configuration.BasePath + "/games/" + gameId + "/hosts/" + hostId + "/checks/"

	headerParams := a.Configuration.GenDefaultHeaders()

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	queryParams := url.Values{}
	formParams := make(map[string]string)
	var successPayload = new(StatusCheckResult)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, "POST", checkInfo, headerParams, queryParams, formParams, "", nil)
	if err != nil {
		if httpResponse != nil {
			return successPayload, NewAPIResponse(httpResponse.RawResponse), err
		}
		return successPayload, nil, err
	}
	code := httpResponse.StatusCode()
	if code != 201 && code != 200 {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), errors.New(string(httpResponse.Body()))
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Hosts API
 * The hosts endpoint returns information about games currently being hosted and known about by the system.
 *
 * @param gameId Game to look for hosts under.
 * @param status Status(es) of hosts to return. If not given, the default is Wait, Play, Relay.
 * @param hoster Name or part of a name of a hoster.
 * @param country Countries for a host.
 * @return *HostList
 */
func (a HostsApi) GamesGameIdHostsGet(gameId string, details string, status []string, hoster string, country []string) (*HostList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/games/{game_id}/hosts"
	path = strings.Replace(path, "{"+"game_id"+"}", fmt.Sprintf("%v", gameId), -1)

	headerParams := a.Configuration.GenDefaultHeaders()
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range status {
			queryParams.Add("status", value)
		}
	} else {
		if len(status) > 0 {
			stat := a.Configuration.APIClient.ParameterToString(status, collectionFormat)
			queryParams.Add("status", stat)
		}
	}
	if hoster != "" {
		queryParams.Add("player", a.Configuration.APIClient.ParameterToString(hoster, ""))
	}
	if details != "" {
		queryParams.Add("player-details", details)
	}
	queryParams.Add("history", "all")
	if collectionFormat == "multi" {
		for _, value := range country {
			queryParams.Add("country", value)
		}
	} else {
		if len(country) > 0 {
			queryParams.Add("country", a.Configuration.APIClient.ParameterToString(country, collectionFormat))
		}
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(HostList)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Host check
 * Check whether a given host is active or not
 *
 * @param offset Offset the list of returned results by this amount. Default is zero.
 * @param limit Number of items to retrieve. Default is 5, maximum is 100.
 * @return *UserHistory
 */
func (a HostsApi) CheckHost(game string, ip net.IP, port int, retries uint8, full bool) (*StatusCheckResult, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/games/{game_id}/hosts/check"
	path = strings.Replace(path, "{"+"game_id"+"}", fmt.Sprintf("%s", game), -1)

	headerParams := a.Configuration.GenDefaultHeaders()
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	ipPort := ip.String()
	if port != 0 {
		ipPort = net.JoinHostPort(ipPort, fmt.Sprintf("%d", port))
	}
	queryParams.Add("ip", a.Configuration.APIClient.ParameterToString(ipPort, ""))
	if retries > 0 {
		queryParams.Add("retries", a.Configuration.APIClient.ParameterToString(fmt.Sprintf("%d", retries), ""))
	}
	if full {
		queryParams.Add("full", "yes")
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(StatusCheckResult)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	if httpResponse.StatusCode() != 200 {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), errors.New(string(httpResponse.Body()))
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Post wait
 */
func (a HostsApi) DeclareWait(userId uint64, game, announcer string, length time.Duration, message string) (*HosterStatus, *APIResponse, error) {
	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/games/{game_id}/hosts"
	path = strings.Replace(path, "{"+"game_id"+"}", fmt.Sprintf("%s", game), -1)

	headerParams := a.Configuration.GenDefaultHeaders()
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody = make(map[string]string)
	var fileName string
	var fileBytes []byte

	postBody["waiting"] = "true"
	postBody["announcer"] = announcer
	postBody["player"] = fmt.Sprintf("%d", userId)
	if message != "" {
		postBody["message"] = message
	}
	if length != 0 {
		postBody["length"] = fmt.Sprintf("%ds", int64(length.Seconds()))
	} else if message == "" {
		postBody["length"] = "0"
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(HosterStatus)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	code := httpResponse.StatusCode()
	if code != 200 && code != 409 {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), errors.New(string(httpResponse.Body()))
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err

}

/**
 * Post host
 * This is used post that someone is hosting a game.
 *
 */
func (a HostsApi) DeclareHost(userId uint64, game, announcer string, message string, ip net.IP, port int) (*HosterStatus, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/games/{game_id}/hosts"
	path = strings.Replace(path, "{"+"game_id"+"}", fmt.Sprintf("%s", game), -1)

	headerParams := a.Configuration.GenDefaultHeaders()
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody = make(map[string]string)
	var fileName string
	var fileBytes []byte

	postBody["announcer"] = announcer
	postBody["player"] = fmt.Sprintf("%d", userId)
	if ip != nil {
		ipPort := ip.String()
		if port != 0 {
			ipPort = net.JoinHostPort(ipPort, fmt.Sprintf("%d", port))
		}
		postBody["ip"] = ipPort
	} else if port != 0 {
		postBody["port"] = fmt.Sprintf("%d", port)
	}
	if message != "" {
		postBody["message"] = message
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(HosterStatus)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	code := httpResponse.StatusCode()
	if code != 200 && code != 409 {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), errors.New(string(httpResponse.Body()))
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * User Activity
 * The User Activity endpoint returns data about a user&#39;s hosts.
 *
 * @param offset Offset the list of returned results by this amount. Default is zero.
 * @param limit Number of items to retrieve. Default is 5, maximum is 100.
 * @return *UserHistory
 */
func (a HostsApi) HistoryGet(offset int32, limit int32) (*UserHistory, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/history"

	headerParams := a.Configuration.GenDefaultHeaders()
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	queryParams.Add("offset", a.Configuration.APIClient.ParameterToString(offset, ""))
	queryParams.Add("limit", a.Configuration.APIClient.ParameterToString(limit, ""))

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(UserHistory)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	if httpResponse.StatusCode() != 200 {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), errors.New(string(httpResponse.Body()))
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}
